PRODUCT DESCRIPTION
-------------------
The purpose of the application is to track the nutrition information of the food a person comsumes, especially the stuff you want to limit: sodium, cholesterol, saturated fat, carbs, and of course, calories.  The idea is that if you actually see the data, you're more likely to adhere to the recommended daily limits, and therefore eat more healthily -- maybe even lose weight!

I have firsthand experience of this and can attest to its persuasive power: I lost over 20 pounds in just a couple months when I logged my daily consumption in a spreadsheet, but then slowly gained it back when I stopped doing it.  And the reason I stopped had nothing to do with any dietary cravings -- it was because updating a spreadsheet every day is a pain in the butt and I got tired of it!  So the primary objective of this app's design is to make it easy to use, while still providing detailed, accurate information -- possibly even incorporating a voice interface.


VISUAL DESIGN
-------------
The application has three main "layers", which maps nicely into three main UI views, plus a separate fourth view:

1. INGREDIENTS
This layer records the nutrition information of "low-level" foods: basically, whatever you might buy in a grocery store.  This could range from simple table salt to complex prepared meals, but every food listed in this layer MUST provide nutrition information, supplied by either the manufacturer, the vendor, or reliable third parties like the USDA.  The focus is on foods that are typically used as ingredients in cooking recipes.

The nutrition information provided is basically what you see in the government-mandated nutrition label for any food product sold in the US, and optionally the item's price.  Nutrition info is specific to a particular product from a particular brand, so if you buy canned tomatoes made by two different companies, that's two different entries in the list, even if they are otherwise exactly identical.

We can provide some default data for this list for some "generic" foods like fresh fruit and vegetables, but for the most part it will be up to the user to enter the data for the foods they purchase.

2. MEALS
This layer tracks the nutrition information of meals which are composed of INGREDIENTS in the proper proportions, and thus provides composite nutrition information.  For example, a "PBJ" meal might consist of two servings of whole wheat bread, two servings of chunky peanut butter, and two servings of blueberry preserves; the resultant nutrition for the meal info would be calculated as the sum of the nutrition data for those ingredients.

The exact composition of any meal is at the discretion of the user, but MUST consist of items listed in the INGREDIENTS list.  Because that depends on the exact brands and varieties available, there is no "universal" meal recipe, even for simple meals.  For example, the PBJ recipe would depend on what type and brand of bread, peanut butter, and jam a user purchases.

Again, we can provide a few simple meals as examples, but to be accurate the list really has to be entered by the user based on their own ingredient purchases and what meals they actually eat!

3. DAILY LOG
This layer tracks daily consumption of food as a number of servings of MEALS.  And again, as a result it tracks the same composite nutrition data.  Daily consumption data can be color-coded according to its relation to the USDA limits.  For example, if you've consumed too much salt in a day, your daily log's "sodium" column might be color-coded as red.  Users will be able to alter their daily logs at will, as some entries might be "hypothetical", to see what the data might show for a number of different possible meal plans.

4. RECIPES
The MEALS layer only lists a meal's components, not how to put them together.  A RECIPE lists the steps needed to make a particular MEAL.  This step is entirely optional.  It's just a convenient place to store recipes.

Later on we can add additional views with cool data visualization, like bar charts or pie charts.

As you might have noticed, the DAILY LOG is composed of MEALS, which are in turn composed of INGREDIENTS.  So the hardest part for the user will be in entering a reasonably complete INGREDIENT list.  You might think that this would be impractical because there are simply too many different foods, and thus too much data to enter.  But in practice, people don't actually vary their diet and food purchases all that much.  It will admittedly be onerous to set up the INGREDIENTS and MEALS lists at first, but as time goes on the user will need to do it less and less often, since more and more of the foods they eat will already be in the database.

Ultimately, updating the DAILY LOG will constitute the majority of the effort in using the app.  But even if users don't want to bother with the DAILY LOG, just the data provided by the MEALS layer is still invaluable, as it gives a great deal of insight into what's really "good to eat".  I can tell you that I learned a lot of surprising things from this data!

Now... I realize that in reality, a typical user will be far too lazy to enter all this data, even if we make this the easiest-to-use app in the world.  But I'm not looking to sell this app!  I'm just interested in (a) using it for myself (and I've already entered a huge amount of INGREDIENT and MEAL data); (b) getting practice using the relevant development technologies; and (c) having a decent-looking portfolio app that I can casually show off in an interview.


TECHNICAL DESIGN
----------------
The main objective of the technical design is to use a representative set of technologies across the entire spectrum of application development, with a preference for the most popular techs in use today -- especially the free/open source ones!  This includes not only the techs used IN the app, but also the techs used to MAKE the app.

The bonus is that once you demonstrate a familiarity with a certain TYPE of tech/tool, it's easy to make the argument (e.g., in an interview) that using any other tech/tool of that type is just a matter of superficial detail, which you can easily look up on the Internet.


Back end and container services
-------------------------------
I want to go with the LAMP stack: Linux, Apache Web Server, MySQL, and Python.  That doesn't include orchestration, container, or deployment tools, though, so those techs would be in addition to that stack.
AWS/Kubernetes/Docker/??? (I have to see when I get to this point in my learning what to choose here)
Apache Web Server
MySQL
Django/Python

Design and development tools
----------------------------
Jira - bug/issue tracking, though maybe just use Git for this if Jira is too unwieldy
Jenkins/Git Actions - CI/CD (again, need to study up before I make decisions on this)
Git - version control
Slack - chat/video conferencing/screen sharing
diagrams.net (formerly known as draw.io) - tech diagrams including database schemas and flowcharts
Figma - wireframe/prototyping tool
VS Code - code editor and its plentiful plugins
ES Lint - JS linter
Stylelint - CSS linter
Prettier - auto code formatter
Vite - local app server & JS bundling tool

Languages and frameworks
------------------------
HTML
CSS
JavaScript/Typescript
React 
Chakra UI? possibly other React libraries?  I was going to add a table library, but I think it might be a good exercise to do our own table UI
NPM/NodeJS
Python
no Java? - strange how I've barely seen any menion of Java and nothing at all of C/C++/C# for back end technology!  It's all JavaScript and Python these days.  Even Ruby and PHP got more mention than Java and C++.

We'll start off working on the front end, and then move to the back end as we gain knowledge.  Working on the front end also has the advantage that we can run the app locally, just mocking up any connection to the back end until the real thing is available.


DEVELOPMENT METHODOLOGIES
-------------------------
- Agile
We will use an agile development process, which once the back end is available will (if practical!) include continuous integration/delivery/deployment and  auto-testing.  The emphasis here is not just on short development cycles (and I mean SHORT!  like, one day MAX), but in being... well... agile!  The initial design will undoubtedly contain a lot of holes and flaws, but we'll figure them out and fill them in as we go.  New input and ideas are not just welcome, but necessary.

- Pair programming?  maybe
- Code reviews?  maybe
I would undoubtedly use these techniques on any real team I managed, but it's just the two of us, and we are VERY, VERY strapped for time, so I don't know if we can squeeze in luxuries like this.


BASIC ARCHITECTURE
------------------
- Single-page App (SPA)
The app will be a single-page app based on React.  This means that instead of loading new web pages when you click on internal links, the app instead keeps the same webpage loaded all the time and only replaces UI components when you navigate around.  This gives it a snappier feel and makes it run better on mobile devices.  This is achieved via an add-on library called React Router, which is trivially simple to use -- literally just a few lines of JSX to add it to the app.

- Mobile Support
I want to look into React Native eventually, but that may have to wait until later.  This is a React framework that allows you to write an app once and compile the same source to run on both PC and handheld devices natively.  When written in normal React/JavaScript, the app will run in a *browser window* on mobile devices, which is fine as long as we adhere to styling guidelines that account for window size; but as a native app, it would be a bona-fide android app you would get in the app store.

This is something for later, though.  I've already verified that React Native works with Typescript and that converting a vanilla React app to React Native isn't too painful, so incorporating it later is an option.

- Data Model
Despite the hand-wringing about data entry above, the actual physical size of the data involved in this app is quite small: currently my entire food dataset in Excel is less than 200 MB.  Even if we double that, we're well within what can comfortably run in a browser window or handheld device.  So it's entirely plausible to retrieve the ENTIRE dataset from the back end up front and store the whole thing in memory while the app is being used.

If we REALLY wanted to future-proof this thing, we could paginate the data from the start, but that would make it slower and make operations like searching, sorting and filtering much more problematic.  Plus... I don't know how to do that yet, lol!  So for now I say we go with the simpler brute-force approach.  If we ever have to refactor to incorporate pagination, it will be a nightmare, but we'll cross that bridge when we come to it.

The data will live in a little MySQL database on the server.  I've used MySQL before, most recently in a little toy app I wrote a couple years ago to solve the daily New York Times Spelling Bee puzzle. :P  The only challenge in this regard, I think, will be in figuring out how to talk to it from the back end app.

As for how to ship the data back and forth between the back end and the front end... well, that's another thing I hope to learn in the next couple of weeks in my back end course, but I expect it will be a web service of some kind.  I actually have a lot of experience with web services, although that experience is, like the rest of it, VERY old and rusty.  The only challenge there, I think, will be the next item on the list...

- Security and Authentication
I'm actually a bit worried about this subject.  Since the app will be running free out the the wild (i.e., it will be on an AWS server exposed to the Internet), solid security is an absolute must, even for a piddly little app like this, and that is something I have very little experience with.  Again, this is a subject in the back end course I'm taking, but based on what I've seen from this course so far, I'm worried that what they're teaching will be too abstract and high-level to give adequate guidance for an actual implemenation.  We'll see!

- Deployment
One way or another this app will be running on an AWS server.  I actually do have some relatively recent experience with AWS -- I had a Minecraft server running on AWS for a couple years -- so that will help, but deploying a web app with back end code and database support is substantially more complicated, so we'll see.

Since I was last in the game, "orchestration" products like Kubernetes have emerged.  These products take a declarative syntax (i.e., something like a JSON or HTML file) and automatically manage all the container setup and deployment for you.  So, for example, to set up the app environment I wouldn't have to know all the cryptic details of AWS, I'd just have to know all the cryptic details of Kubernetes. :P  Seriously though, the advantage is that you set it up once and then never have to deal with it again, plus you avoid the potential for human error each deployment.

This also ties into continuous integration.  CI is actually massive overkill for a tiny project with only 1 or 2 contributors, but I want to get experience with it.  Jenkins is probably the product to use here, though Git Actions is new and I'm guessing more accessible.  But it is a "nice to have" rather than a requirement, so it's something I'll add later, time permitting.
